#!/usr/bin/env bash

[[ "${TRACE}" ]] && set -x
set -euo pipefail

DEV_SESSION="dev"

error() {
  echo "Error: $*" >&2
  return 1
}

show_usage() {
  echo "Usage: tmux-dev <action> [options]"
  echo ""
  echo "All processes run as windows in the '$DEV_SESSION' tmux session."
  echo "Window names are auto-generated from directory + command."
  echo ""
  echo "Actions:"
  echo "  start <command...>   - Start (or restart) a dev server"
  echo "  stop <name>          - Stop a dev server window"
  echo "  status <name>        - Check if window is running or exited"
  echo "  logs <name> [lines]  - Show recent logs from window"
  echo "  list                 - List all dev server windows"
  echo ""
  echo "Examples:"
  echo "  cd ~/code/myapp && tmux-dev start npm run dev"
  echo "    -> creates window 'myapp-npm-dev'"
  echo ""
  echo "  tmux-dev logs myapp-npm-dev 100"
  echo "  tmux-dev stop myapp-npm-dev"
  echo "  tmux-dev list"
  echo ""
  echo "Attach to session: tmux attach -t $DEV_SESSION"
}

session_exists() {
  tmux has-session -t "$DEV_SESSION" 2>/dev/null
}

window_exists() {
  tmux list-windows -t "$DEV_SESSION" -F "#{window_name}" 2>/dev/null | grep -qx "$1"
}

window_status() {
  local name="$1"
  if ! window_exists "$name"; then
    echo "not_found"
    return
  fi
  local output
  output=$(tmux capture-pane -t "$DEV_SESSION:$name" -p -S - 2>/dev/null || true)
  if echo "$output" | grep -q "=== Exited with code:"; then
    local code
    code=$(echo "$output" | grep "=== Exited with code:" | tail -1 | sed 's/.*code: //')
    echo "exited:$code"
  else
    echo "running"
  fi
}

ensure_session() {
  if ! session_exists; then
    tmux new-session -d -s "$DEV_SESSION" -n "_placeholder"
  fi
}

find_envrc_dir() {
  local check_dir="$1"
  while [[ "$check_dir" != "/" ]]; do
    if [[ -f "$check_dir/.envrc" ]]; then
      echo "$check_dir"
      return 0
    fi
    check_dir=$(dirname "$check_dir")
  done
  return 1
}

generate_name() {
  local command="$*"
  local folder
  folder=$(basename "$PWD")

  local cmd_words=($command)
  local main_cmd="${cmd_words[0]}"
  local slug=""

  case "$main_cmd" in
    npm|yarn|pnpm|bun)
      if [[ "${cmd_words[1]:-}" == "run" ]]; then
        slug="${main_cmd}-${cmd_words[2]:-run}"
      else
        slug="${main_cmd}-${cmd_words[1]:-start}"
      fi
      ;;
    go)
      if [[ "${cmd_words[1]:-}" == "run" ]]; then
        local path="${cmd_words[2]:-main}"
        path="${path%/}"          # strip trailing slash
        path="${path%/main.go}"   # strip /main.go suffix
        path="${path%.go}"        # strip .go suffix
        path="${path##*/}"        # last path component = binary name
        # go run . or empty -> use directory name
        [[ "$path" == "." || -z "$path" ]] && path="$folder"
        slug="go-${path}"
      else
        slug="go-${cmd_words[1]:-build}"
      fi
      ;;
    python|python3|uv)
      local script="${cmd_words[1]:-main}"
      [[ "$script" == "run" ]] && script="${cmd_words[2]:-main}"
      script="${script##*/}"
      script="${script%.py}"
      slug="py-${script}"
      ;;
    make)
      slug="${cmd_words[1]:-make}"
      ;;
    just)
      # Use the last argument as the target name (e.g., just rust::watch session-tracker -> session-tracker)
      slug="${cmd_words[-1]}"
      # If only `just <recipe>`, use the recipe name
      [[ "$slug" == "just" ]] && slug="${cmd_words[1]:-just}"
      ;;
    nix)
      # Extract package name from flake reference (e.g., .#niri-switcher -> niri-switcher)
      local flake_ref=""
      for arg in "${cmd_words[@]:2}"; do
        if [[ "$arg" == *"#"* ]]; then
          flake_ref="${arg##*#}"
          break
        fi
      done
      slug="${flake_ref:-nix}"
      ;;
    *)
      slug="${main_cmd}${cmd_words[1]:+-${cmd_words[1]}}"
      ;;
  esac

  slug="${slug,,}"
  slug="${slug//[^a-z0-9-]/-}"

  # Strip noise words (start, dev, run, make) from slug
  local noise_words=("start" "dev" "run" "make")
  for word in "${noise_words[@]}"; do
    slug="${slug//-${word}-/-}"  # -word- -> -
    slug="${slug/#${word}-/}"    # word- at start -> empty
    slug="${slug/%-${word}/}"    # -word at end -> empty
  done

  slug="${slug//--/-}"
  slug="${slug#-}"
  slug="${slug%-}"

  echo "${folder}-${slug}"
}

handle_start() {
  if [[ $# -lt 1 ]]; then
    error "start requires command
Usage: tmux-dev start <command...>"
  fi

  local command="$*"
  local name
  name=$(generate_name "$command")

  ensure_session

  if window_exists "$name"; then
    echo "Restarting '$name'..."
    tmux kill-window -t "$DEV_SESSION:$name"
  fi

  local cwd="$PWD"

  # Wrap with direnv if .envrc exists in directory tree
  if command -v direnv >/dev/null 2>&1; then
    local envrc_dir
    if envrc_dir=$(find_envrc_dir "$cwd"); then
      echo "Found .envrc in $envrc_dir - using direnv"
      command="direnv exec \"$cwd\" $command"
    fi
  fi

  echo "Starting '$name': $command"
  # Wrap command to keep window open on exit (success or failure)
  # Trailing colon forces tmux to auto-pick window index in the specified session
  tmux new-window -t "${DEV_SESSION}:" -n "$name" -c "$cwd" \
    "bash -c '${command}; echo; echo \"=== Exited with code: \$?\"; read -p \"Press enter to close...\"'"

  # Store command and cwd for reference
  tmux set-option -t "$DEV_SESSION:$name" @cmd "$command"
  tmux set-option -t "$DEV_SESSION:$name" @cwd "$cwd"

  # Clean up placeholder window if it exists
  if tmux list-windows -t "$DEV_SESSION" -F "#{window_name}" | grep -qx "_placeholder"; then
    tmux kill-window -t "$DEV_SESSION:_placeholder" 2>/dev/null || true
  fi

  sleep 1
  if ! window_exists "$name"; then
    echo "✗ Window exited immediately"
    echo "Try running manually: cd $cwd && $command"
    return 1
  fi

  echo "✓ Window '$name' started in session '$DEV_SESSION'"
  echo "WINDOW_NAME: $name"
  echo ""
  echo "=== $name (streaming for 10s) ==="

  local last_output=""
  for _ in {1..10}; do
    if ! window_exists "$name"; then
      echo ""
      echo "✗ Process exited"
      return 1
    fi
    local current_output
    current_output=$(tmux capture-pane -t "$DEV_SESSION:$name" -p -S - | grep -v '^$')
    if [[ "$current_output" != "$last_output" ]]; then
      # Print only new lines
      if [[ -n "$last_output" ]]; then
        local last_lines new_lines
        last_lines=$(echo "$last_output" | wc -l)
        new_lines=$(echo "$current_output" | tail -n "+$((last_lines + 1))")
        [[ -n "$new_lines" ]] && echo "$new_lines"
      else
        echo "$current_output"
      fi
      last_output="$current_output"
    fi
    sleep 1
  done

  echo ""
  echo "=== Detached (use 'tmux-dev logs $name' for more) ==="
}

handle_stop() {
  if [[ $# -lt 1 ]]; then
    error "stop requires window name"
  fi

  local name="$1"

  if ! session_exists; then
    echo "No dev session exists"
    return 1
  fi

  if ! window_exists "$name"; then
    echo "Window '$name' does not exist"
    return 1
  fi

  tmux kill-window -t "$DEV_SESSION:$name"
  echo "✓ Window '$name' stopped"
}

handle_logs() {
  if [[ $# -lt 1 ]]; then
    error "logs requires window name"
  fi

  local name="$1"
  local lines="${2:-50}"

  if ! session_exists || ! window_exists "$name"; then
    echo "Window '$name' does not exist"
    handle_list
    return 1
  fi

  echo "=== $name (last $lines lines) ==="
  tmux capture-pane -t "$DEV_SESSION:$name" -p -S - | grep -v '^$' | tail -n "$lines"
}

handle_status() {
  if [[ $# -lt 1 ]]; then
    error "status requires window name"
  fi

  local name="$1"

  if ! session_exists; then
    echo "$name: not_found"
    return 1
  fi

  local status
  status=$(window_status "$name")

  case "$status" in
    running)
      echo "$name: running"
      ;;
    exited:*)
      local code="${status#exited:}"
      echo "$name: exited (code $code)"
      return 1
      ;;
    not_found)
      echo "$name: not_found"
      return 1
      ;;
  esac
}

handle_list() {
  if ! session_exists; then
    echo "No dev server session"
    return 0
  fi

  local windows
  windows=$(tmux list-windows -t "$DEV_SESSION" -F "#{window_name}" | grep -v "^_placeholder$" || true)

  if [[ -z "$windows" ]]; then
    echo "No dev server windows"
    return 0
  fi

  echo "Dev server windows (session: $DEV_SESSION):"
  while IFS= read -r name; do
    local status
    status=$(window_status "$name")
    case "$status" in
      running)
        printf "  %-30s running\n" "$name"
        ;;
      exited:*)
        local code="${status#exited:}"
        printf "  %-30s exited (code %s)\n" "$name" "$code"
        ;;
    esac
  done <<< "$windows"
  echo ""
  echo "Attach: tmux attach -t $DEV_SESSION"
}

main() {
  if [[ $# -lt 1 ]]; then
    show_usage
    return 1
  fi

  local action="$1"
  shift

  case "$action" in
    start) handle_start "$@" ;;
    stop) handle_stop "$@" ;;
    status) handle_status "$@" ;;
    logs) handle_logs "$@" ;;
    list) handle_list ;;
    *)
      echo "Unknown action: $action"
      show_usage
      return 1
      ;;
  esac
}

main "$@"
