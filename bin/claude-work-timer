#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = [
#   "claude-code-sdk",
#   "typing-extensions",
# ]
# ///
"""
Claude Code Work Timer - Runs Claude Code for a specified duration
and creates a PR when time is nearly up.
"""

import argparse
import asyncio
import logging
import sys
import uuid
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any

from claude_code_sdk import (
    AssistantMessage,
    ClaudeCodeOptions,
    TextBlock,
    query,
)

# System prompt template for long-running tasks
LONG_TASK_SYSTEM_PROMPT = """
You are working on a long-duration task that will run for {duration} hours.
The session started at {start_time} and will end at {end_time}.
You have until {work_until} to work on the task, after which you'll need to wrap up.

Please work continuously and thoroughly on the task.
IMPORTANT: Continuously update a file called 'tasklog.md' with your progress, decisions, and current status. This file should contain a running log of what you're working on, what you've completed, and what's next.

The workflow for each iteration is:
1. CODE: Continue implementing the task, making progress on features
2. REVIEW: Use the code-reviewer agent to review your changes
3. FIX: Address ALL issues identified by the code reviewer
4. SIMPLIFY: Use the complexity-reducer agent to analyze complexity
5. APPLY: Implement the simplifications suggested by the agent

This structured workflow ensures high-quality, maintainable code.
Remember you have ample time, so be thorough rather than rushed.

When you receive the wrap-up prompt, finish your current work, run all tests and linting, and create a PR.
"""


async def run_claude_query(prompt: str, options: ClaudeCodeOptions) -> bool:
    """Run a single Claude Code query and print the response."""
    logger = logging.getLogger(__name__)
    try:
        async for message in query(prompt=prompt, options=options):
            if isinstance(message, AssistantMessage):
                for block in message.content:
                    if isinstance(block, TextBlock):
                        logger.info(block.text)
        return True
    except Exception as e:
        error_str = str(e)
        logger.error(f"Error running Claude: {error_str}")

        # Check for API errors that we should retry
        if any(
            err in error_str for err in ["500", "529", "Overloaded", "api_error", "503"]
        ):
            return False

        raise e


async def run_claude_task(
    prompt: str,
    base_options: dict[str, Any],
    session_id: str,
    resume: bool,
    max_retries: int = 2,
    retry_delay: int = 180,
):
    """
    Run a Claude task with automatic retry logic for API errors.

    Args:
        prompt: The prompt to send to Claude
        base_options: Base options dict for ClaudeCodeOptions
        session_id: Session ID for the conversation
        max_retries: Maximum number of retry attempts
        retry_delay: Delay in seconds between retries

    Returns:
        True if successful, False if failed after retries
    """
    logger = logging.getLogger(__name__)

    # Create initial options
    options = ClaudeCodeOptions(
        **base_options,
    )
    if resume:
        options.resume = session_id
    else:
        options.extra_args = {"session-id": session_id}

    # Try the initial request
    result = await run_claude_query(prompt, options)

    if result:
        return True

    # Handle API errors with retries
    for attempt in range(max_retries):
        logger.info(f"API error detected (attempt {attempt + 1}/{max_retries})")
        logger.info(
            f"Waiting {retry_delay} seconds before resuming session {session_id}..."
        )
        await asyncio.sleep(retry_delay)

        # Create resume options
        if session_id:
            resume_options = ClaudeCodeOptions(
                **base_options,
                resume=session_id,
            )
        else:
            # If no session ID, just retry with same options
            resume_options = options

        result = await run_claude_query(
            "Please continue where you left off", resume_options
        )

        if result:
            return True
        else:
            return False

    logger.error(f"Failed after {max_retries} retry attempts")
    return False


async def main():
    # Setup logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        datefmt="%H:%M:%S",
    )
    logger = logging.getLogger(__name__)

    parser = argparse.ArgumentParser(
        description="Run Claude Code for a specified duration"
    )
    parser.add_argument("task", help="Initial task/prompt for Claude Code")
    parser.add_argument(
        "-d",
        "--duration",
        type=float,
        default=0.0,
        help="Duration in hours (default: 0.0)",
    )
    parser.add_argument(
        "-b",
        "--buffer",
        type=int,
        default=10,
        help="Buffer time in minutes before finish (default: 10)",
    )
    parser.add_argument("--cwd", type=Path, help="Working directory for Claude Code")
    parser.add_argument(
        "--debug", action="store_true", help="Run only one iteration for debugging"
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose debug logging"
    )
    parser.add_argument(
        "--continue-conversation",
        action="store_true",
        help="Continue the conversation from the last message",
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Bypass permissions",
        default=True,
    )
    parser.add_argument(
        "-i",
        "--iterations",
        type=int,
        help="Number of iterations to run (default: 1)",
        default=1,
    )

    args = parser.parse_args()
    logger.info(f"Arguments: {args}")

    # iterations and duration are mutually exclusive
    if args.iterations > 0 and args.duration > 0:
        logger.error("Iterations and duration are mutually exclusive")
        return 1

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Calculate timing
    start_time = datetime.now()
    if args.duration > 0:
        end_time = start_time + timedelta(hours=args.duration)
        buffer_time = timedelta(minutes=args.buffer)
        work_until = end_time - buffer_time
    else:
        end_time = None
        work_until = None

    # Generate a session ID for this work session
    session_id = str(uuid.uuid4())
    logger.info(f"Session ID: {session_id}")

    # Setup base options
    base_options = {
        "permission_mode": "bypassPermissions" if args.force else None,
        "cwd": args.cwd,
    }

    # Only add the long task system prompt if not in debug mode and using duration
    if not args.debug and args.duration > 0:
        base_options["append_system_prompt"] = LONG_TASK_SYSTEM_PROMPT.format(
            duration=args.duration,
            start_time=start_time.strftime("%H:%M:%S"),
            end_time=end_time.strftime("%H:%M:%S"),
            work_until=work_until.strftime("%H:%M:%S"),
        )

    if args.duration > 0:
        logger.info(f"Starting work session: {args.duration} hours")
        logger.info(f"Will work until: {work_until.strftime('%H:%M:%S')}")
        logger.info(f"Final wrap-up at: {end_time.strftime('%H:%M:%S')}")
    else:
        logger.info(f"Starting iteration-based session: {args.iterations} iterations")
    logger.info("-" * 50)

    iteration = 1

    while (work_until is not None and datetime.now() < work_until) or (
        args.iterations > 0 and iteration <= args.iterations
    ):
        remaining_time = work_until - datetime.now() if work_until is not None else None
        remaining_iterations = args.iterations - iteration + 1

        logger.info(f"--- Iteration {iteration} ---")
        if remaining_time is not None:
            logger.info(f"Time remaining: {remaining_time}")
        else:
            logger.info(f"Iterations remaining: {remaining_iterations}")

        # Generate a new session ID for this iteration
        iteration_session_id = str(uuid.uuid4())
        logger.info(f"Iteration session ID: {iteration_session_id}")

        # Step 1: Continue coding the task (fresh context each iteration)
        logger.info("[Step 1/5] Doing work on task...")
        if iteration == 1:
            prompt = args.task
        else:
            prompt = f"Continue working on the current task: {args.task}. Focus on making progress and implementing features. Update tasklog.md with what you're doing."
        success = await run_claude_task(
            prompt=prompt,
            base_options=base_options,
            session_id=iteration_session_id,
            resume=False,
        )

        if not success:
            logger.error(
                "Error in coding phase, waiting 5 minutes before continuing..."
            )
            await asyncio.sleep(300)
            continue

        # Step 2: Code review
        logger.info("[Step 2/5] Running code review...")
        success = await run_claude_task(
            prompt="Use the code-reviewer agent to review all the code you've written in this iteration. The agent will identify any issues with quality, security, or maintainability.",
            base_options=base_options,
            session_id=iteration_session_id,
            resume=True,
        )

        if not success:
            logger.error(
                "Error in review phase, waiting 5 minutes before continuing..."
            )
            await asyncio.sleep(300)
            continue

        # Step 3: Fix review issues
        logger.info("[Step 3/5] Fixing issues from code review...")
        success = await run_claude_task(
            prompt="Fix ALL issues identified by the code reviewer. Make sure to address every concern raised about code quality, security, and maintainability.",
            base_options=base_options,
            session_id=iteration_session_id,
            resume=True,
        )

        if not success:
            logger.error(
                "Error fixing review issues, waiting 5 minutes before continuing..."
            )
            await asyncio.sleep(300)
            continue

        # Step 4: Analyze complexity
        logger.info("[Step 4/5] Analyzing code complexity...")
        success = await run_claude_task(
            prompt="Use the complexity-reducer agent to analyze any overly complex code from this iteration. The agent will identify unnecessary abstractions and suggest simplifications.",
            base_options=base_options,
            session_id=iteration_session_id,
            resume=True,
        )

        if not success:
            logger.error(
                "Error in complexity analysis, waiting 5 minutes before continuing..."
            )
            await asyncio.sleep(300)
            continue

        # Step 5: Apply simplifications
        logger.info("[Step 5/5] Applying simplification suggestions...")
        success = await run_claude_task(
            prompt="Apply the simplifications suggested by the complexity-reducer agent. Implement all the recommended changes to make the code simpler and more maintainable.",
            base_options=base_options,
            session_id=iteration_session_id,
            resume=True,
        )

        if not success:
            logger.error(
                "Error applying simplifications, waiting 5 minutes before continuing..."
            )
            await asyncio.sleep(300)
            continue

        iteration += 1

        # Break after first iteration if debug mode
        if args.debug:
            logger.info("[DEBUG MODE: Stopping after one iteration]")
            break

        # Small delay between iterations
        await asyncio.sleep(5)

    # Final wrap-up and PR creation
    logger.info("=" * 50)
    logger.info("TIME TO WRAP UP!")
    logger.info("=" * 50)

    wrap_up_prompt = (
        "Please finish up the current work, ensure all tests pass, "
        "run any linting/formatting commands."
    )

    # Generate a new session ID for wrap-up
    wrapup_session_id = str(uuid.uuid4())
    logger.info(f"Wrap-up session ID: {wrapup_session_id}")

    await run_claude_task(
        prompt=wrap_up_prompt,
        base_options=base_options,
        session_id=wrapup_session_id,
        resume=False,
    )

    logger.info("Work session completed!")
    return 0


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
