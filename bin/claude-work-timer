#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = [
#   "claude-code-sdk",
#   "typing-extensions",
# ]
# ///
"""
Claude Code Work Timer - Runs Claude Code for a specified duration
and creates a PR when time is nearly up.
"""

import argparse
import asyncio
import logging
import sys
import uuid
from datetime import datetime, timedelta
from pathlib import Path

from claude_code_sdk import (
    AssistantMessage,
    ClaudeCodeOptions,
    TextBlock,
    query,
)

# System prompt template for long-running tasks
LONG_TASK_SYSTEM_PROMPT = """
You are working on a long-duration task that will run for {duration} hours.
The session started at {start_time} and will end at {end_time}.
You have until {work_until} to work on the task, after which you'll need to wrap up.

Please work continuously and thoroughly on the task.
IMPORTANT: Continuously update a file called 'tasklog.md' with your progress, decisions, and current status. This file should contain a running log of what you're working on, what you've completed, and what's next.
CRITICAL: After every major code change, use the code review agent to review your code.
Fix ALL issues the code reviewer identifies before proceeding.
The code reviewer helps ensure high-quality, secure code.

Remember you have ample time, so be thorough rather than rushed.

When you receive the wrap-up prompt, finish your current work, run all tests and linting, and create a PR.
"""


async def run_claude_query(prompt: str, options: ClaudeCodeOptions = None):
    """Run a single Claude Code query and print the response."""
    logger = logging.getLogger(__name__)
    try:
        async for message in query(prompt=prompt, options=options):
            if isinstance(message, AssistantMessage):
                for block in message.content:
                    if isinstance(block, TextBlock):
                        logger.info(block.text)
        return "success"
    except Exception as e:
        error_str = str(e)
        logger.error(f"Error running Claude: {error_str}")

        # Check for API errors that we should retry
        if any(
            err in error_str for err in ["500", "529", "Overloaded", "api_error", "503"]
        ):
            return "api_error"

        return "error"


async def run_claude_task(
    prompt: str,
    base_options: dict,
    session_id: str = None,
    continue_conversation: bool = False,
    max_retries: int = 2,
    retry_delay: int = 180,
):
    """
    Run a Claude task with automatic retry logic for API errors.

    Args:
        prompt: The prompt to send to Claude
        base_options: Base options dict for ClaudeCodeOptions
        session_id: Session ID for resuming on error
        continue_conversation: Whether to continue existing conversation
        max_retries: Maximum number of retry attempts
        retry_delay: Delay in seconds between retries

    Returns:
        True if successful, False if failed after retries
    """
    logger = logging.getLogger(__name__)

    # Create initial options
    options = ClaudeCodeOptions(
        **base_options,
        continue_conversation=continue_conversation,
        extra_args={"session-id": session_id}
        if session_id and not continue_conversation
        else {},
    )

    # Try the initial request
    result = await run_claude_query(prompt, options)

    if result == "success":
        return True
    elif result != "api_error":
        return False

    # Handle API errors with retries
    for attempt in range(max_retries):
        logger.info(f"API error detected (attempt {attempt + 1}/{max_retries})")
        logger.info(
            f"Waiting {retry_delay} seconds before resuming session {session_id}..."
        )
        await asyncio.sleep(retry_delay)

        # Create resume options
        if session_id:
            resume_options = ClaudeCodeOptions(
                **base_options,
                resume=session_id,
            )
        else:
            # If no session ID, just retry with same options
            resume_options = options

        result = await run_claude_query(
            "Please continue where you left off", resume_options
        )

        if result == "success":
            return True
        elif result != "api_error":
            return False

    logger.error(f"Failed after {max_retries} retry attempts")
    return False


async def main():
    # Setup logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        datefmt="%H:%M:%S",
    )
    logger = logging.getLogger(__name__)

    parser = argparse.ArgumentParser(
        description="Run Claude Code for a specified duration"
    )
    parser.add_argument("task", help="Initial task/prompt for Claude Code")
    parser.add_argument(
        "-d",
        "--duration",
        type=float,
        default=1.0,
        help="Duration in hours (default: 1.0)",
    )
    parser.add_argument(
        "-b",
        "--buffer",
        type=int,
        default=10,
        help="Buffer time in minutes before finish (default: 10)",
    )
    parser.add_argument("--cwd", type=Path, help="Working directory for Claude Code")
    parser.add_argument(
        "--debug", action="store_true", help="Run only one iteration for debugging"
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose debug logging"
    )
    parser.add_argument(
        "--continue-conversation",
        action="store_true",
        help="Continue the conversation from the last message",
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Bypass permissions",
        default=True,
    )

    args = parser.parse_args()
    logger.info(f"Arguments: {args}")

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Calculate timing
    start_time = datetime.now()
    end_time = start_time + timedelta(hours=args.duration)
    buffer_time = timedelta(minutes=args.buffer)
    work_until = end_time - buffer_time

    # Generate a session ID for this work session
    session_id = str(uuid.uuid4())
    logger.info(f"Session ID: {session_id}")

    # Setup base options
    base_options = {
        "permission_mode": "bypassPermissions" if args.force else None,
        "cwd": args.cwd,
    }

    # Only add the long task system prompt if not in debug mode
    if not args.debug:
        base_options["append_system_prompt"] = LONG_TASK_SYSTEM_PROMPT.format(
            duration=args.duration,
            start_time=start_time.strftime("%H:%M:%S"),
            end_time=end_time.strftime("%H:%M:%S"),
            work_until=work_until.strftime("%H:%M:%S"),
        )

    logger.info(f"Starting work session: {args.duration} hours")
    logger.info(f"Will work until: {work_until.strftime('%H:%M:%S')}")
    logger.info(f"Final wrap-up at: {end_time.strftime('%H:%M:%S')}")
    logger.info("-" * 50)

    # Initial task
    logger.info(f"Starting task: {args.task}")
    success = await run_claude_task(
        prompt=args.task,
        base_options=base_options,
        session_id=session_id,
        continue_conversation=False,
    )

    if not success:
        logger.error("Failed to start initial task")
        return 1

    # Continue working until time to wrap up
    iteration = 1

    while datetime.now() < work_until:
        remaining = work_until - datetime.now()
        logger.info(f"--- Iteration {iteration} ---")
        logger.info(f"Time remaining: {remaining}")

        success = await run_claude_task(
            prompt=f"Continue working on the current task: {args.task}",
            base_options=base_options,
            session_id=session_id,
            continue_conversation=args.continue_conversation,
        )

        if not success:
            logger.error("Error occurred, waiting 5 minutes before continuing...")
            await asyncio.sleep(300)  # Wait 5 minutes
            continue

        iteration += 1

        # Break after first iteration if debug mode
        if args.debug:
            logger.info("[DEBUG MODE: Stopping after one iteration]")
            break

        # Small delay between iterations
        await asyncio.sleep(5)

    # Final wrap-up and PR creation
    logger.info("=" * 50)
    logger.info("TIME TO WRAP UP!")
    logger.info("=" * 50)

    wrap_up_prompt = (
        "Please finish up the current work, ensure all tests pass, "
        "run any linting/formatting commands."
    )

    await run_claude_task(
        prompt=wrap_up_prompt,
        base_options=base_options,
        session_id=session_id,
        continue_conversation=args.continue_conversation,
    )

    logger.info("Work session completed!")
    return 0


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
