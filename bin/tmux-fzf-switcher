#!/usr/bin/env bash
# Two-stage session/window switcher
# Press h/j/k/l for session, then h/j/k/l for window
# Press / for fuzzy search mode
# Press q or Esc to cancel

# Session order - loaded from config file
SESSION_ORDER=()
CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/tmux/session-order.conf"
if [[ -f "$CONFIG_FILE" ]]; then
  # shellcheck source=/dev/null
  source "$CONFIG_FILE"
fi

KEYS=(h j k l u i o p n m , .)

# Claude session tracking
CLAUDE_SESSIONS_FILE="$HOME/.claude/active-sessions.json"

# Build map of tmux window IDs to Claude state
declare -A CLAUDE_STATUS_MAP
load_claude_sessions() {
  CLAUDE_STATUS_MAP=()
  [[ -f "$CLAUDE_SESSIONS_FILE" ]] || return

  # Parse JSON and build map: tmux_window_id -> state
  # States: waiting (needs attention), responding, tool_running
  while IFS= read -r line; do
    local tmux_id state
    tmux_id=$(echo "$line" | cut -d'|' -f1)
    state=$(echo "$line" | cut -d'|' -f2)
    [[ -n "$tmux_id" && "$tmux_id" != "null" ]] && CLAUDE_STATUS_MAP["$tmux_id"]="$state"
  done < <(jq -r 'to_entries[] | "\(.value.tmux_window_id)|\(.value.state // "unknown")"' "$CLAUDE_SESSIONS_FILE" 2>/dev/null)
}

get_windows() {
  # Format: session:index window_id window_name
  tmux list-windows -a -F '#{session_name}:#{window_index} #{window_id} #{window_name}' |
    grep -v '^drawer-'
}

get_sorted_sessions() {
  local windows="$1"
  local all_sessions=()

  while IFS= read -r sess; do
    all_sessions+=("$sess")
  done < <(echo "$windows" | cut -d: -f1 | awk '!seen[$0]++')

  # Sort by preference
  local sorted=()
  for preferred in "${SESSION_ORDER[@]}"; do
    for sess in "${all_sessions[@]}"; do
      if [[ "$sess" == "$preferred" ]]; then
        sorted+=("$sess")
        break
      fi
    done
  done
  # Add remaining
  for sess in "${all_sessions[@]}"; do
    local found=0
    for s in "${sorted[@]}"; do
      if [[ "$sess" == "$s" ]]; then
        found=1
        break
      fi
    done
    if [[ $found -eq 0 ]]; then
      sorted+=("$sess")
    fi
  done

  printf '%s\n' "${sorted[@]}"
}

key_to_idx() {
  case "$1" in
  h) echo 0 ;;
  j) echo 1 ;;
  k) echo 2 ;;
  l) echo 3 ;;
  u) echo 4 ;;
  i) echo 5 ;;
  o) echo 6 ;;
  p) echo 7 ;;
  n) echo 8 ;;
  m) echo 9 ;;
  ,) echo 10 ;;
  .) echo 11 ;;
  *) echo -1 ;;
  esac
}

# Load Claude sessions and get windows
load_claude_sessions
ALL_WINDOWS=$(get_windows)
WINDOWS=$(echo "$ALL_WINDOWS" | grep -v -E '^(dev|scratch):')
SESSIONS=()
while IFS= read -r sess; do
  SESSIONS+=("$sess")
done < <(get_sorted_sessions "$WINDOWS")

# Format window line with Claude status (no subshell - uses global FORMATTED_LINE)
FORMATTED_LINE=""
format_window_line() {
  local sess_idx="$1"   # session:index
  local window_id="$2"  # @N
  local window_name="$3"

  local status="${CLAUDE_STATUS_MAP[$window_id]}"
  if [[ -n "$status" ]]; then
    case "$status" in
      waiting)
        # Yellow + bold - needs user attention
        FORMATTED_LINE="${sess_idx} \033[1;33m[waiting]\033[0m ${window_name}"
        ;;
      responding)
        # Blue - Claude is actively working
        FORMATTED_LINE="${sess_idx} \033[34m[working]\033[0m ${window_name}"
        ;;
      idle)
        # Gray - finished, no action needed
        FORMATTED_LINE="${sess_idx} \033[90m[idle]\033[0m ${window_name}"
        ;;
      *)
        # Gray - unknown state
        FORMATTED_LINE="${sess_idx} \033[90m[${status}]\033[0m ${window_name}"
        ;;
    esac
  else
    FORMATTED_LINE="${sess_idx} ${window_name}"
  fi
}

# Build display
build_full_display() {
  local sidx=0
  for sess in "${SESSIONS[@]}"; do
    local skey="?"
    if [[ $sidx -lt ${#KEYS[@]} ]]; then
      skey="${KEYS[$sidx]}"
    fi

    local widx=0
    while IFS=' ' read -r sess_idx window_id window_name; do
      local wkey="?"
      if [[ $widx -lt ${#KEYS[@]} ]]; then
        wkey="${KEYS[$widx]}"
      fi
      format_window_line "$sess_idx" "$window_id" "$window_name"
      printf "\033[33m[%s%s]\033[0m %b\n" "$skey" "$wkey" "$FORMATTED_LINE"
      ((widx++))
    done < <(echo "$WINDOWS" | grep "^${sess}:")
    ((sidx++))
  done
}

build_session_display() {
  local filter_idx="$1"
  local target_sess="${SESSIONS[$filter_idx]}"

  echo ""
  printf "\033[36mSession: %s\033[0m\n" "$target_sess"
  echo ""

  local widx=0
  while IFS=' ' read -r sess_idx window_id window_name; do
    local wkey="?"
    if [[ $widx -lt ${#KEYS[@]} ]]; then
      wkey="${KEYS[$widx]}"
    fi
    format_window_line "$sess_idx" "$window_id" "$window_name"
    printf "\033[33m[%s]\033[0m %b\n" "$wkey" "$FORMATTED_LINE"
    ((widx++))
  done < <(echo "$WINDOWS" | grep "^${target_sess}:")
}

run_fzf_search() {
  echo "$ALL_WINDOWS" |
    fzf --no-border --height=100% --with-nth=1,3.. --header="Type to search, Enter to select" |
    cut -d' ' -f1 |
    xargs -I {} tmux switch-client -t {}
}

# Clear screen and show initial list
clear
echo "h/j/k/l = select session | / = search | q/Esc = cancel"
echo ""
build_full_display | head -n $(($(tput lines) - 3))

# Read first key (session)
read -rsn1 key1

# Handle special keys
if [[ "$key1" == "/" ]]; then
  run_fzf_search
  exit 0
fi

if [[ "$key1" == "q" || "$key1" == $'\e' ]]; then
  exit 0
fi

session_idx=$(key_to_idx "$key1")
if [[ $session_idx -lt 0 || $session_idx -ge ${#SESSIONS[@]} ]]; then
  echo "Invalid session key: $key1"
  exit 1
fi

# Show filtered view
clear
echo "h/j/k/l = select window | q/Esc = cancel"
build_session_display "$session_idx" | head -n $(($(tput lines) - 2))

# Read second key (window)
read -rsn1 key2

if [[ "$key2" == "q" || "$key2" == $'\e' ]]; then
  exit 0
fi

window_idx=$(key_to_idx "$key2")
if [[ $window_idx -lt 0 ]]; then
  echo "Invalid window key: $key2"
  exit 1
fi

# Get target
target_sess="${SESSIONS[$session_idx]}"
target_window=$(echo "$WINDOWS" | grep "^${target_sess}:" | sed -n "$((window_idx + 1))p" | cut -d' ' -f1)

if [[ -z "$target_window" ]]; then
  echo "Window not found"
  exit 1
fi

tmux switch-client -t "$target_window"
