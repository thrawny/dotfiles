# ===== Exports =====
export PYTHONDONTWRITEBYTECODE=1
export PYTHONUNBUFFERED=1
export GOPATH=$HOME/go
export EDITOR=nvim
export AWS_PAGER=''
export K9S_CONFIG_DIR=$HOME/.config/k9s
# Locale settings for UTF-8 support (including tmux)
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LC_CTYPE=en_US.UTF-8

# Replicate Oh My Zsh's WORDCHARS behavior
# Oh My Zsh sets this to just '_-' for more granular word navigation
export WORDCHARS='_-'

# ===== PATH Configuration =====
PATH=$PATH:$GOPATH/bin:$HOME/dotfiles/bin
[[ ":$PATH:" != *":/usr/local/bin:"* ]] && PATH="/usr/local/bin:${PATH}"
[[ ":$PATH:" != *":$HOME/.local/bin:"* ]] && PATH="$HOME/.local/bin:${PATH}"
[[ ":$PATH:" != *":$HOME/.claude/local:"* ]] && PATH="$HOME/.claude/local:${PATH}"
[[ ":$PATH:" != *":$HOME/.cargo/bin:"* ]] && PATH="$HOME/.cargo/bin:${PATH}"
[[ ":$PATH:" != *":$HOME/.npm-global/bin:"* ]] && PATH="$HOME/.npm-global/bin:${PATH}"
export PATH

# ===== Zinit Installation =====
ZINIT_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"
if [ ! -d "$ZINIT_HOME" ]; then
    print -P "%F{33}▓▒░ %F{220}Installing %F{33}ZDHARMA-CONTINUUM%F{220} Initiative Plugin Manager (%F{33}zdharma-continuum/zinit%F{220})…%f"
    command mkdir -p "$(dirname $ZINIT_HOME)" && command chmod g-rwX "$ZINIT_HOME"
    command git clone https://github.com/zdharma-continuum/zinit "$ZINIT_HOME" && \
        print -P "%F{33}▓▒░ %F{34}Installation successful.%f%b" || \
        print -P "%F{160}▓▒░ The clone has failed.%f%b"
fi
source "${ZINIT_HOME}/zinit.zsh"

# ===== OS-specific Configuration =====
HAS_WORKBREW=$([[ -d /opt/workbrew ]] && echo 1 || echo 0)

if [[ "$(uname)" == "Darwin" ]]; then
  if [[ "$HAS_WORKBREW" == "0" ]]; then
    eval "$(/opt/homebrew/bin/brew shellenv)"
  fi
  export ASDF_DIR=/opt/homebrew/opt/asdf/libexec
else
  alias pbcopy='wl-copy'
  alias pbpaste='wl-paste'
fi

# Homebrew completions
if type brew &>/dev/null; then
  FPATH=$(brew --prefix)/share/zsh/site-functions:$FPATH
fi

# ===== Zinit Annexes =====
zinit light-mode for \
    zdharma-continuum/zinit-annex-bin-gem-node \
    zdharma-continuum/zinit-annex-patch-dl \
    zdharma-continuum/zinit-annex-rust

# ===== Essential Plugins (Load Immediately) =====
# Git plugin for aliases
zinit snippet OMZP::git

# Vim mode for zsh (load early for proper integration)
# Disable vi mode when running inside Neovim terminal for clearer mental model
if [ -z "$NVIM" ]; then
  zinit ice depth=1
  zinit light jeffreytse/zsh-vi-mode

  # Configure vi-mode settings
  ZVM_VI_INSERT_ESCAPE_BINDKEY=jk  # Use jk to escape to normal mode
  ZVM_LINE_INIT_MODE=$ZVM_MODE_INSERT  # Start in insert mode
fi

# Unalias specific git aliases to use custom ones
unalias -m "gpo" 2>/dev/null
unalias -m "gp" 2>/dev/null
unalias -m "gcam" 2>/dev/null
unalias -m "gcm" 2>/dev/null

# ===== Completions =====
zinit ice blockf atpull'zinit creinstall -q .'
zinit light zsh-users/zsh-completions

# Initialize completion system (ignore insecure directories from Homebrew)
autoload -Uz compinit
# VS Code needs full compinit, others can ignore insecure directories
# Force fresh completion rebuild if dump is corrupted
if [[ ! -f ~/.zcompdump || ! -s ~/.zcompdump ]]; then
    if [[ "$TERM_PROGRAM" == "vscode" ]] || [[ -n "$VSCODE_INJECTION" ]]; then
        compinit -u
    else
        compinit
    fi
elif [[ "$TERM_PROGRAM" == "vscode" ]] || [[ -n "$VSCODE_INJECTION" ]]; then
    compinit -u
else
    compinit -i
fi

zinit cdreplay -q

# Source custom completions (after compinit)
if [[ -d ~/.zsh/completions ]]; then
  for f in ~/.zsh/completions/*; do
    [[ -f "$f" ]] && source "$f"
  done
fi

# ===== Deferred Plugins (Turbo Mode) =====
# Load these plugins 0.5 seconds after prompt
zinit wait lucid for \
    OMZP::docker \
    OMZP::python

# Load kubectl completions if kubectl is installed
if command -v kubectl &> /dev/null; then
    source <(kubectl completion zsh)
fi

# Use dyff for kubectl diff if available (YAML-aware diffing)
if command -v dyff &> /dev/null; then
    export KUBECTL_EXTERNAL_DIFF="kubectl-dyff"
fi


# ===== Performance Plugins ====

# Syntax highlighting (load after compinit)
zinit ice wait lucid
zinit light zdharma-continuum/fast-syntax-highlighting

# Auto suggestions (with vi-mode compatibility)
# Make forward-word perform partial accept (next word) instead of full accept
# Must be set before loading zsh-autosuggestions
ZSH_AUTOSUGGEST_PARTIAL_ACCEPT_WIDGETS+=(
  forward-word
  emacs-forward-word
  vi-forward-word
)
# Ensure these widgets are NOT treated as full-accept
if typeset -p ZSH_AUTOSUGGEST_ACCEPT_WIDGETS >/dev/null 2>&1; then
  ZSH_AUTOSUGGEST_ACCEPT_WIDGETS=(${ZSH_AUTOSUGGEST_ACCEPT_WIDGETS:#forward-word})
  ZSH_AUTOSUGGEST_ACCEPT_WIDGETS=(${ZSH_AUTOSUGGEST_ACCEPT_WIDGETS:#emacs-forward-word})
  ZSH_AUTOSUGGEST_ACCEPT_WIDGETS=(${ZSH_AUTOSUGGEST_ACCEPT_WIDGETS:#vi-forward-word})
fi
zinit ice wait lucid atload"!_zsh_autosuggest_start"
zinit light zsh-users/zsh-autosuggestions

# Fix for zsh-vi-mode compatibility with autosuggestions and fzf
# Only define this function when vi-mode is enabled (not in Neovim)
if [ -z "$NVIM" ]; then
  zvm_after_init() {
    [ -f /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh ] && \
      source /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh

    # Re-initialize fzf keybindings after vi-mode to prevent conflicts
    if command -v fzf &> /dev/null; then
      eval "$(fzf --zsh)"
    fi

  }
else
  # When in Neovim terminal, initialize fzf and keybindings directly
  if command -v fzf &> /dev/null; then
    eval "$(fzf --zsh)"
  fi

  bindkey ^e end-of-line
fi

# Bind Ctrl+F to forward-word for partial autosuggestion accept
bindkey ^F forward-word
bindkey ^f forward-word

# History substring search
zinit ice wait lucid
zinit light zsh-users/zsh-history-substring-search

# ===== History Configuration =====
HISTSIZE=50000
SAVEHIST=50000
HISTFILE="$HOME/.zsh_history"
setopt EXTENDED_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_VERIFY
setopt SHARE_HISTORY
setopt APPEND_HISTORY
setopt INC_APPEND_HISTORY

# ===== Directory Navigation =====
setopt AUTO_CD
setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt PUSHDMINUS

# ===== Completion Configuration =====
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
zstyle ':completion:*' menu select

# ===== Aliases =====
alias h='history'
alias l='ls -lh'
alias fig="docker-compose"

alias vim=nvim
alias svh="sudo nvim /etc/hosts"
alias k='kubectl'
alias kt='stern'
alias ka='kubectl apply -f'
alias kn='kubectl -n kube-system'
alias ki='kubectl -n istio-system'
alias kp='kubectl get pods'
alias gsha='git rev-parse HEAD | cut -c1-9'
alias klf='kubectl logs -f'
alias kl='kubectl logs'
alias ku='kubectl config use-context'
alias hb='gh repo view --web'
alias gotest='golangci-lint fmt && golangci-lint run --fix && go test $(go list ./... | grep -v /lab/)'
alias b='bat -p --pager=never'
alias vkp='watch -n 1 kubectl get pods'
alias kvp='watch -n 1 kubectl get pods'
alias v='watch -n 1'
alias kd='kc drain --ignore-daemonsets --delete-local-data --force'
alias gcam="git add -A && git commit -m"
alias tfa='terraform apply'
alias bu='brew upgrade'
alias c='claude'
alias cy='claude --dangerously-skip-permissions'
alias pr='gh pr create --web'
alias striplines='tr -d "\n"'
alias kd='kubectl delete'
alias gcm='git commit -m'
alias gp='git push --force-with-lease --force-if-includes'
alias gw='git-gtr'
alias tp='terraform plan'
alias ta='terraform apply'
alias taf='terraform apply -auto-approve'

if bat --version &>/dev/null && [[ -o interactive ]]; then
  alias cat='bat --style=grid,snip --theme "Monokai Extended Origin"'
fi

if command -v eza &>/dev/null && [[ -o interactive ]]; then
  alias ls='eza --icons --group-directories-first'
  # Monokai spectrum palette: purple dirs, orange exec, pink perms, cyan user
  export EZA_COLORS="di=38;5;141:ex=38;5;209:ln=38;5;141:ur=38;5;204:uw=38;5;204:ux=38;5;204:ue=38;5;204:gr=38;5;204:gw=38;5;204:gx=38;5;204:tr=38;5;204:tw=38;5;204:tx=38;5;204:uu=38;5;81:gu=38;5;81:da=38;5;243:sn=38;5;255:sb=38;5;243:ga=38;5;81:gm=38;5;227:gd=38;5;204:gv=38;5;141"
fi

if [[ "$(uname)" == "Darwin" ]]; then
  alias cct="security find-generic-password -s \"Claude Code-credentials\" -w | jq -c '{claudeAiOauth}'"
fi
alias ct="cat ~/.codex/auth.json | jq -c"

# ===== Functions =====
function gtrm() {
  git tag --delete $1 && git push --delete origin $1
}

function gpo() {
  git push -u origin $(git rev-parse --abbrev-ref HEAD)
}

function gwg() {
  cd "$(git gtr go "$1")"
}

function kcaev() {
  envsubst < $1 | kubectl apply -f -
}

function ktc() {
  stern $1 -c $1 -e "kube-probe|Checking status...|health check|Accepted connection from /100" ${@:2}
}

function kcpf() {
  while true; do
    kubectl port-forward "$@"
  done
}

function asudo() {
  export $(awsudo default)
}

function dbp() {
  docker build -t $1 . && docker push $1
}

function ktjq() {
  stern $1 --output raw | jq -r -R 'fromjson? | "\(.["@timestamp"]) [\(.level)] - \(.message)"' ${@:2}
}

function uuid() {
  python3 -c "import uuid;print(uuid.uuid4())"
}


function al() {
  profile=${AWS_PROFILE:-default}
  aws sso login --profile $profile
}

function ecr_login() {
  ACCOUNT_ID=$(aws --profile $1 sts get-caller-identity --query Account --output text)
  REGION=$(aws --profile $1 configure get region)
  ECR_URL="$ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com"
  echo "Logging into ecr for profile $1 with ECR URL $ECR_URL"
  aws --profile $1 ecr get-login-password | docker login --username AWS --password-stdin $ECR_URL
}

function wtfpipeoutput () {
  cat <<EOF
command &> out          # for both going to out, works in bash and zsh
command >out 2>&1       # for both going to out
command > out 2>error   # std out to out, stderr to error
EOF
}

# ===== FZF Configuration =====
# Configure fzf defaults (keybindings are loaded in zvm_after_init to avoid conflicts)
if command -v fzf &> /dev/null; then
  # Better fzf defaults
  export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border --info=inline'

  # Use fd for faster file searching if available
  if command -v fd &> /dev/null; then
    export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git --exclude .venv --exclude node_modules'
    export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    export FZF_ALT_C_COMMAND='fd --type d --hidden --follow --exclude .git --exclude .venv --exclude node_modules'
  fi

  # Preview files with bat if available
  if command -v bat &> /dev/null; then
    export FZF_CTRL_T_OPTS="--preview 'bat --style=numbers --color=always --line-range :100 {}'"
  fi
fi

# ===== External Tools =====
# ASDF
[ -f /opt/homebrew/opt/asdf/libexec/asdf.sh ] && . /opt/homebrew/opt/asdf/libexec/asdf.sh

# Zoxide (smart directory navigation)
# Only initialize in interactive shells to avoid errors in non-interactive contexts
if command -v zoxide &> /dev/null && [[ -o interactive ]]; then
  eval "$(zoxide init --cmd cd zsh)"
fi

# Direnv
if direnv version &>/dev/null; then
  eval "$(direnv hook zsh)"
fi

# ===== Starship Prompt =====
# Initialize Starship prompt if installed
if command -v starship &> /dev/null; then
  eval "$(starship init zsh)"
else
  # Fallback prompt if Starship is not installed
  PS1='%F{blue}%~%f %F{green}❯%f '
fi

# ===== Auto-start tmux in devpod =====
if [[ -n "$DEVPOD" ]] && [[ -z "$TMUX" ]]; then
  # Attach to existing session or create new one, then exit shell when done
  tmux attach-session -t main 2>/dev/null || tmux new-session -s main
  exit
fi

# Make exit detach from tmux in devpod sessions
if [[ -n "$DEVPOD" ]] && [[ -n "$TMUX" ]]; then
  alias exit='tmux detach'
fi

# ===== Local Overrides =====
[ -f ~/.zsh.local ] && source ~/.zsh.local
